# ğŸ“š GuÃ­a de PrÃ¡ctica: Ãrboles y Grafos
## Para Aprobar el Parcial de Algoritmos

---

## ğŸ¯ PARTE 1: LECTURA DE ENUNCIADOS

### Ejercicio de TraducciÃ³n 1
**Enunciado:** "Implementar `int buscar(int valor)` que devuelve el Ã­ndice donde se encuentra `valor`. Si no existe, devolver -1. Si la lista estÃ¡ vacÃ­a, devolver -1."

**Pregunta:** Â¿QuÃ© validaciones necesitÃ¡s?

<details>
<summary>Ver respuesta</summary>

```cpp
int buscar(int valor) {
    // ValidaciÃ³n: lista vacÃ­a
    if (lista == nullptr) {
        return -1;
    }
    
    // BÃºsqueda normal...
    // Si no se encuentra, return -1
}
```
</details>

---

### Ejercicio de TraducciÃ³n 2
**Enunciado:** "Implementar `void eliminar(int pos)` que elimina el nodo en la posiciÃ³n `pos`. Si `pos` estÃ¡ fuera de rango [0, size), no hacer nada."

**Pregunta:** Â¿QuÃ© validaciones necesitÃ¡s?

<details>
<summary>Ver respuesta</summary>

```cpp
void eliminar(int pos) {
    // ValidaciÃ³n: fuera de rango
    if (pos < 0 || pos >= size) {
        return; // No hacer nada
    }
    
    // Eliminar...
}
```
</details>

---

### Ejercicio de TraducciÃ³n 3
**Enunciado:** "Calcular la suma de todos los nodos con valor mayor a 10. Si el Ã¡rbol estÃ¡ vacÃ­o, devolver 0."

**Pregunta:** Â¿QuÃ© validaciones necesitÃ¡s?

<details>
<summary>Ver respuesta</summary>

```cpp
int sumarMayoresA10(Nodo* nodo) {
    // Caso base: Ã¡rbol vacÃ­o
    if (nodo == nullptr) {
        return 0;
    }
    
    // Sumar solo si valor > 10
    int suma = (nodo->dato > 10) ? nodo->dato : 0;
    
    return suma + sumarMayoresA10(nodo->izq) + sumarMayoresA10(nodo->der);
}
```
</details>

---

## ğŸŒ³ PARTE 2: ÃRBOLES BINARIOS - RECURSIÃ“N

### Nivel 1: Contar y Recorrer

#### Ejercicio 2.1: Contar nodos
```cpp
/**
 * Devolver la cantidad total de nodos del Ã¡rbol.
 * Si estÃ¡ vacÃ­o, devolver 0.
 */
struct Nodo {
    int dato;
    Nodo* izq;
    Nodo* der;
};

int contarNodos(Nodo* nodo) {
    // COMPLETAR
}
```

**Pistas:**
- Caso base: `nodo == nullptr`
- Â¿QuÃ© devuelvo en caso base?
- Â¿CÃ³mo combino izq + der?

---

#### Ejercicio 2.2: Contar hojas
```cpp
/**
 * Devolver la cantidad de hojas (nodos sin hijos).
 * Si estÃ¡ vacÃ­o, devolver 0.
 */
int contarHojas(Nodo* nodo) {
    // COMPLETAR
}
```

**Pistas:**
- Â¿CuÃ¡ndo un nodo es hoja?
- NecesitÃ¡s 2 casos base

---

#### Ejercicio 2.3: Altura del Ã¡rbol
```cpp
/**
 * Devolver la altura del Ã¡rbol (longitud del camino mÃ¡s largo
 * desde raÃ­z hasta hoja).
 * Un Ã¡rbol vacÃ­o tiene altura -1.
 * Un Ã¡rbol con solo raÃ­z tiene altura 0.
 */
int altura(Nodo* nodo) {
    // COMPLETAR
}
```

**Pistas:**
- Â¿QuÃ© devuelvo si es nullptr?
- Â¿Uso max() o min() para combinar?

---

### Nivel 2: BÃºsqueda y ValidaciÃ³n

#### Ejercicio 2.4: Buscar valor
```cpp
/**
 * Devolver true si el valor existe en el Ã¡rbol.
 * Si estÃ¡ vacÃ­o, devolver false.
 */
bool existe(Nodo* nodo, int valor) {
    // COMPLETAR
}
```

**Pistas:**
- Â¿CuÃ¡ndo devuelvo true inmediatamente?
- Uso OR (||) o AND (&&) para combinar?

---

#### Ejercicio 2.5: Encontrar mÃ¡ximo
```cpp
/**
 * Devolver el valor mÃ¡ximo del Ã¡rbol.
 * Si estÃ¡ vacÃ­o, devolver INT_MIN.
 */
int encontrarMaximo(Nodo* nodo) {
    // COMPLETAR
}
```

**Pistas:**
- NecesitÃ¡s comparar: nodo->dato vs max(izq, der)
- IncluÃ­ `<climits>` para INT_MIN

---

#### Ejercicio 2.6: Verificar si es BST
```cpp
/**
 * Devolver true si el Ã¡rbol es un Ãrbol Binario de BÃºsqueda
 * (todos los nodos izquierdos < raÃ­z < todos los derechos).
 * Un Ã¡rbol vacÃ­o es BST.
 */
bool esBST(Nodo* nodo, int minValor, int maxValor) {
    // COMPLETAR
}
```

**Pistas:**
- PasÃ¡ rangos vÃ¡lidos [min, max] en cada llamada
- IniciÃ¡ con `esBST(raiz, INT_MIN, INT_MAX)`

---

### Nivel 3: Casos Especiales

#### Ejercicio 2.7: Contar nodos con exactamente un hijo
```cpp
/**
 * Devolver cantidad de nodos que tienen exactamente UN hijo
 * (izquierdo o derecho, pero no ambos).
 */
int contarNodosConUnHijo(Nodo* nodo) {
    // COMPLETAR
}
```

---

#### Ejercicio 2.8: Verificar si estÃ¡ balanceado
```cpp
/**
 * Un Ã¡rbol estÃ¡ balanceado si para cada nodo,
 * |altura(izq) - altura(der)| <= 1.
 * Devolver true si estÃ¡ balanceado.
 */
bool esBalanceado(Nodo* nodo) {
    // COMPLETAR
    // Pista: necesitÃ¡s una funciÃ³n auxiliar que devuelva
    // la altura Y actualice un flag de balanceado
}
```

---

#### Ejercicio 2.9: Suma de caminos
```cpp
/**
 * Devolver la suma de todos los caminos desde raÃ­z hasta hojas.
 * Ejemplo: Ã¡rbol con raÃ­z=1, izq=2, der=3
 * Caminos: 1->2 (suma 3), 1->3 (suma 4)
 * Total: 7
 */
int sumaCaminos(Nodo* nodo, int sumaActual) {
    // COMPLETAR
}
```

---

## ğŸ•¸ï¸ PARTE 3: GRAFOS - BFS

### Nivel 1: BÃ¡sicos

#### Ejercicio 3.1: Contar nodos alcanzables
```cpp
/**
 * Dado un grafo y un nodo origen, devolver la cantidad
 * de nodos alcanzables desde origen (incluyendo origen).
 * Si origen estÃ¡ fuera de rango [0, nodeCount), devolver 0.
 */
class Grafo {
public:
    static const int MAX = 10;
    int adj[MAX][MAX];
    int nodeCount;
    
    int contarAlcanzables(int origen);
};

int Grafo::contarAlcanzables(int origen) {
    // COMPLETAR
}
```

---

#### Ejercicio 3.2: Verificar conexiÃ³n
```cpp
/**
 * Devolver true si TODOS los nodos son alcanzables desde el nodo 0.
 * (El grafo es conexo desde 0).
 */
bool esConexo() {
    // COMPLETAR
    // Pista: hacÃ© BFS desde 0 y contÃ¡ cuÃ¡ntos visitaste
}
```

---

#### Ejercicio 3.3: Distancia mÃ­nima
```cpp
/**
 * Devolver la distancia mÃ­nima (cantidad de aristas)
 * entre origen y destino.
 * Si no hay camino, devolver -1.
 * Si origen == destino, devolver 0.
 */
int distanciaMinima(int origen, int destino) {
    // COMPLETAR
    // Pista: guardÃ¡ la distancia junto con cada nodo en la cola
}
```

---

### Nivel 2: Con Condiciones

#### Ejercicio 3.4: Camino evitando nodo
```cpp
/**
 * Devolver true si existe un camino de origen a destino
 * SIN pasar por el nodo bloqueado.
 * Si origen o destino == bloqueado, devolver false.
 */
bool existeCaminoEvitando(int origen, int destino, int bloqueado) {
    // COMPLETAR
}
```

---

#### Ejercicio 3.5: Nivel de un nodo
```cpp
/**
 * Devolver el nivel (distancia desde raÃ­z=0) del nodo buscado.
 * Si no existe, devolver -1.
 * RaÃ­z estÃ¡ en nivel 0.
 */
int nivelDelNodo(int raiz, int buscado) {
    // COMPLETAR
}
```

---

## ğŸ”„ PARTE 4: GRAFOS - DFS RECURSIVO

### Nivel 1: BÃ¡sicos

#### Ejercicio 4.1: Contar alcanzables (DFS)
```cpp
/**
 * Igual que 3.1 pero usando DFS recursivo.
 */
int contarAlcanzablesDFS(int origen, bool visitado[]) {
    // COMPLETAR
}
```

---

#### Ejercicio 4.2: Detectar ciclo
```cpp
/**
 * Devolver true si el grafo DIRIGIDO tiene al menos un ciclo.
 */
class GrafoDirigido {
public:
    static const int MAX = 10;
    int adj[MAX][MAX];
    int nodeCount;
    
    bool tieneCiclo();
    
private:
    bool tieneCicloDFS(int nodo, bool visitado[], bool enProceso[]);
};

bool GrafoDirigido::tieneCiclo() {
    // COMPLETAR
    // Pista: necesitÃ¡s 2 arrays: visitado[] y enProceso[]
}
```

---

#### Ejercicio 4.3: Encontrar componentes conexas
```cpp
/**
 * Devolver la cantidad de componentes conexas en un grafo NO dirigido.
 * Ejemplo: Si tenÃ©s 3 "islas" separadas, devolver 3.
 */
int contarComponentesConexas() {
    // COMPLETAR
    // Pista: hacÃ© DFS desde cada nodo no visitado
}
```

---

## ğŸ“ PARTE 5: EJERCICIOS INTEGRADORES

### Ejercicio 5.1: Ãrbol desde lista de adyacencia
```cpp
/**
 * Dado un grafo que representa un Ã¡rbol (sin ciclos),
 * calcular su altura usando BFS desde la raÃ­z.
 * La raÃ­z es el nodo 0.
 */
int alturaArbolDesdeBFS(int raiz) {
    // COMPLETAR
}
```

---

### Ejercicio 5.2: Validar Ã¡rbol binario desde grafo
```cpp
/**
 * Dado un grafo, devolver true si representa un Ã¡rbol binario vÃ¡lido:
 * - Cada nodo tiene como mÃ¡ximo 2 hijos
 * - No hay ciclos
 * - Hay exactamente un nodo raÃ­z (sin padres)
 */
bool esArbolBinarioValido() {
    // COMPLETAR
}
```

---

## ğŸ“‹ CHECKLIST PARA CADA EJERCICIO

Antes de escribir cÃ³digo, completÃ¡ esto en papel:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ANÃLISIS DEL PROBLEMA               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Â¿QuÃ© me dan?                        â”‚
â”‚ â–¡ Ãrbol / Grafo / Lista             â”‚
â”‚ â–¡ Â¿QuÃ© atributos tiene?             â”‚
â”‚                                     â”‚
â”‚ Â¿QuÃ© me piden?                      â”‚
â”‚ â–¡ Contar / Buscar / Verificar       â”‚
â”‚ â–¡ Â¿QuÃ© tipo devuelvo?               â”‚
â”‚                                     â”‚
â”‚ Â¿Validaciones?                      â”‚
â”‚ â–¡ nullptr / vacÃ­o                   â”‚
â”‚ â–¡ Fuera de rango                    â”‚
â”‚ â–¡ Casos especiales                  â”‚
â”‚                                     â”‚
â”‚ Â¿Algoritmo?                         â”‚
â”‚ â–¡ BFS (cola + visitados)            â”‚
â”‚ â–¡ DFS recursivo (caso base)         â”‚
â”‚ â–¡ Otro                              â”‚
â”‚                                     â”‚
â”‚ Â¿QuÃ© necesito?                      â”‚
â”‚ â–¡ Cola / Stack                      â”‚
â”‚ â–¡ Array de visitados                â”‚
â”‚ â–¡ Contador / Flag                   â”‚
â”‚ â–¡ Variables auxiliares              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ MÃ‰TODO DE LAS 5 PREGUNTAS (RecursiÃ³n)

Para CADA ejercicio recursivo:

1. **Â¿QuÃ© estructura?** (Ã¡rbol binario, lista, grafo)
2. **Â¿Caso base?** (nullptr, vacÃ­o, encontrado)
3. **Â¿QuÃ© hago con el nodo actual?** (contar, comparar, sumar)
4. **Â¿QuÃ© hago con resultados recursivos?** (sumar, max, and, or)
5. **Â¿QuÃ© devuelvo?** (int, bool, void, puntero)

---

## ğŸ’¡ PLANTILLAS DE CÃ“DIGO

### Plantilla BFS:
```cpp
int metodoBFS(int origen) {
    // 1. Validaciones
    if (origen < 0 || origen >= nodeCount) return -1;
    
    // 2. Estructuras
    bool visitado[nodeCount] = {false};
    queue<int> cola;
    
    // 3. Iniciar
    visitado[origen] = true;
    cola.push(origen);
    
    // 4. Procesar
    while (!cola.empty()) {
        int actual = cola.front();
        cola.pop();
        
        // Hacer algo con actual...
        
        // Procesar vecinos
        for (int i = 0; i < nodeCount; i++) {
            if (adj[actual][i] == 1 && !visitado[i]) {
                visitado[i] = true;
                cola.push(i);
            }
        }
    }
    
    // 5. Devolver resultado
    return resultado;
}
```

### Plantilla DFS Recursivo:
```cpp
int metodoDFS(Nodo* nodo) {
    // 1. Caso base
    if (nodo == nullptr) {
        return valor_base;
    }
    
    // 2. Procesar nodo actual
    int resultado_actual = // ...
    
    // 3. Llamadas recursivas
    int resultado_izq = metodoDFS(nodo->izq);
    int resultado_der = metodoDFS(nodo->der);
    
    // 4. Combinar y devolver
    return combinar(resultado_actual, resultado_izq, resultado_der);
}
```

---

## ğŸš€ PLAN DE ESTUDIO SUGERIDO

### DÃ­a 1-2: Ãrboles bÃ¡sicos
- Ejercicios 2.1 a 2.3
- Practicar el mÃ©todo de las 5 preguntas

### DÃ­a 3-4: Ãrboles intermedios
- Ejercicios 2.4 a 2.6
- Enfocarse en casos base mÃºltiples

### DÃ­a 5-6: Grafos BFS
- Ejercicios 3.1 a 3.3
- Memorizar la plantilla BFS

### DÃ­a 7-8: Grafos DFS
- Ejercicios 4.1 a 4.3
- Combinar con recursiÃ³n de Ã¡rboles

### DÃ­a 9-10: Repaso e integradores
- Ejercicios 5.1 a 5.2
- Hacer ejercicios de parciales anteriores

---

## âœ… TIPS FINALES

1. **No veas las respuestas inmediatamente**: IntentÃ¡ 15-20 min antes de mirar
2. **UsÃ¡ papel**: DibujÃ¡ el Ã¡rbol/grafo antes de codear
3. **EscribÃ­ comentarios primero**: El cÃ³digo viene despuÃ©s
4. **RevisÃ¡ el checklist**: Antes de dar por terminado
5. **SimulÃ¡ con ejemplos chicos**: Ãrbol de 3 nodos, grafo de 4 nodos

---

**Â¿Dudas? ConsultÃ¡ antes del parcial. Â¡Ã‰xitos!** ğŸ“
